use anchor_client::solana_sdk::pubkey::Pubkey;
use anchor_client::solana_sdk::signature::{Keypair, Signer};
use anchor_client::solana_sdk::system_instruction;
use anchor_client::{Client, Cluster};
use anyhow::Result;
use clap::Parser;
use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::signature::SignerError;
use solana_sdk::signature::{read_keypair_file, Signature};
use solana_sdk::system_program;
use std::fmt;
use std::fmt::Display;
// The `accounts` and `instructions` modules are generated by the framework.
use basic_2::accounts as basic_2_accounts;
use basic_2::instruction as basic_2_instruction;
use basic_2::Counter;
use events::instruction as events_instruction;
use events::MyEvent;
use optional::accounts::Initialize as OptionalInitialize;
use optional::instruction as optional_instruction;
// The `accounts` and `instructions` modules are generated by the framework.
use basic_4::accounts as basic_4_accounts;
use basic_4::instruction as basic_4_instruction;
use basic_4::Counter as CounterAccount;
// The `accounts` and `instructions` modules are generated by the framework.
use crate::Opts;
use anchor_client::solana_client::nonblocking::rpc_client::RpcClient;
use composite::accounts::{Bar, CompositeUpdate, Foo, Initialize};
use composite::instruction as composite_instruction;
use composite::{DummyA, DummyB};
use optional::account::{DataAccount, DataPda};
use solana_sdk::transaction::Transaction;
use std::ops::Deref;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::time::sleep;

pub async fn main() -> Result<()> {
    let opts = Opts::parse();

    // Wallet and cluster params.
    let payer = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json"))
        .expect("Example requires a keypair file");
    let url = Cluster::Custom(
        "http://localhost:8899".to_string(),
        "ws://127.0.0.1:8900".to_string(),
    );

    // Client.
    // let payer = Rc::new(payer);
    let client = Client::new_with_options(url.clone(), &payer, CommitmentConfig::processed());

    println!("\nStarting async test...");
    composite(&client, url.clone(), &payer, opts.composite_pid).await?;
    basic_2(&client, opts.basic_2_pid).await?;
    basic_4(&client, opts.basic_4_pid).await?;

    // Can also use references, since they deref to a signer
    let payer: &Keypair = &payer;
    let client = Client::new_with_options(url, payer, CommitmentConfig::processed());
    events(&client, opts.events_pid).await?;
    optional(&client, opts.optional_pid).await?;
    // Success.
    Ok(())
}

pub async fn composite<C: Deref<Target = impl Signer> + Clone>(
    client: &Client<C>,
    url: Cluster,
    payer: &Keypair,
    pid: Pubkey,
) -> Result<()> {
    // Program client.
    let program = client.program(pid)?;

    // `Initialize` parameters.
    let dummy_a = Keypair::new();
    let dummy_b = Keypair::new();

    // Build and send a transaction.
    program
        .request()
        .instruction(system_instruction::create_account(
            &program.payer(),
            &dummy_a.pubkey(),
            program
                .async_rpc()
                .get_minimum_balance_for_rent_exemption(500)
                .await?,
            500,
            &program.id(),
        ))
        .instruction(system_instruction::create_account(
            &program.payer(),
            &dummy_b.pubkey(),
            program
                .async_rpc()
                .get_minimum_balance_for_rent_exemption(500)
                .await?,
            500,
            &program.id(),
        ))
        .signer(&dummy_a)
        .signer(&dummy_b)
        .accounts(Initialize {
            dummy_a: dummy_a.pubkey(),
            dummy_b: dummy_b.pubkey(),
        })
        .args(composite_instruction::Initialize)
        .send()
        .await?;

    // Assert the transaction worked.
    let dummy_a_pubkey = dummy_a.pubkey();
    let dummy_b_pubkey = dummy_b.pubkey();
    let dummy_a_account: DummyA = program.account(dummy_a_pubkey).await?;
    let dummy_b_account: DummyB = program.account(dummy_b_pubkey).await?;
    assert_eq!(dummy_a_account.data, 0);
    assert_eq!(dummy_b_account.data, 0);

    // let payer_string = payer.to_base58_string();
    let wrapper_keypair = Arc::new(crate::nonblocking::KeypairSendableWrapper::from_keypair(
        payer,
    ));

    let client = Client::new_with_options(
        url.clone(),
        wrapper_keypair.clone(),
        CommitmentConfig::processed(),
    );
    let inner_program = client.program(pid).unwrap();
    let ixes = inner_program
        .request()
        .accounts(CompositeUpdate {
            foo: Foo {
                dummy_a: dummy_a_pubkey.clone(),
            },
            bar: Bar {
                dummy_b: dummy_b_pubkey.clone(),
            },
        })
        .args(composite_instruction::CompositeUpdate {
            dummy_a: 1234,
            dummy_b: 4321,
        })
        .instructions()?;
    let (blockhash, _) = inner_program
        .async_rpc()
        .get_latest_blockhash_with_commitment(CommitmentConfig::processed())
        .await?;
    let tx = Transaction::new_signed_with_payer(
        &ixes,
        Some(&wrapper_keypair.clone().pubkey()),
        &[&wrapper_keypair.clone()],
        blockhash,
    );

    let rpc_client = RpcClient::new(url.url().to_string());

    tokio::spawn(async move {
        rpc_client
            .send_and_confirm_transaction_with_spinner_and_commitment(
                &tx,
                CommitmentConfig::processed(),
            )
            .await
            .map_or_else(
                |e| {
                    eprintln!("Error sending transaction composite: {:?}", e);
                    None
                },
                Some,
            );
    })
    .await?;

    // Assert the transaction worked.
    let dummy_a_account: DummyA = program.account(dummy_a.pubkey()).await?;
    let dummy_b_account: DummyB = program.account(dummy_b.pubkey()).await?;
    assert_eq!(dummy_a_account.data, 1234);
    assert_eq!(dummy_b_account.data, 4321);

    println!("Composite success!");

    Ok(())
}

pub trait SendableSigner: Send + Sync + Signer {}

#[derive(Clone)]
struct KeypairSendableWrapper {
    keypair: [u8; 64],
}

// impl Deref for KeypairSendableWrapper {
//     type Target = Keypair;
//
//     fn deref(&self) -> &Self::Target {
//         let keypair = Keypair::from_bytes(&self.keypair).unwrap();
//         &keypair
//     }
// }

impl Display for KeypairSendableWrapper {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let keypair = Keypair::from_bytes(&self.keypair).map_err(|_| fmt::Error)?;
        write!(f, "{}", keypair.to_base58_string())
    }
}

impl KeypairSendableWrapper {
    pub fn new<T: AsRef<Keypair>>(keypair: T) -> Self {
        Self {
            keypair: keypair.as_ref().to_bytes(),
        }
    }

    pub fn from_keypair(keypair: &Keypair) -> Self {
        Self {
            keypair: keypair.to_bytes(),
        }
    }
}

impl Signer for KeypairSendableWrapper {
    fn try_pubkey(&self) -> std::result::Result<Pubkey, SignerError> {
        // Convert the stored keypair bytes back to a Keypair
        let keypair =
            Keypair::from_bytes(&self.keypair).map_err(|e| SignerError::Custom(e.to_string()))?;

        // Return the public key of the keypair
        Ok(keypair.pubkey())
    }

    fn try_sign_message(&self, message: &[u8]) -> std::result::Result<Signature, SignerError> {
        // Convert the stored keypair bytes back to a Keypair
        let keypair =
            Keypair::from_bytes(&self.keypair).map_err(|e| SignerError::Custom(e.to_string()))?;

        // Sign the message with the keypair
        Ok(keypair.try_sign_message(message)?)
    }

    fn is_interactive(&self) -> bool {
        // This method should return true if the signer requires user interaction to sign messages.
        // In this case, we assume that it does not require user interaction, so we return false.
        false
    }
}

impl SendableSigner for KeypairSendableWrapper {}

pub async fn basic_2<C: Deref<Target = impl Signer> + Clone>(
    client: &Client<C>,
    pid: Pubkey,
) -> Result<()> {
    let program = client.program(pid)?;

    // `Create` parameters.
    let counter = Keypair::new();
    let authority = program.payer();

    // Build and send a transaction.
    program
        .request()
        .signer(&counter)
        .accounts(basic_2_accounts::Create {
            counter: counter.pubkey(),
            user: authority,
            system_program: system_program::ID,
        })
        .args(basic_2_instruction::Create { authority })
        .send()
        .await?;

    let counter_account: Counter = program.account(counter.pubkey()).await?;

    assert_eq!(counter_account.authority, authority);
    assert_eq!(counter_account.count, 0);

    println!("Basic 2 success!");

    Ok(())
}

pub async fn events<C: Deref<Target = impl Signer> + Clone>(
    client: &Client<C>,
    pid: Pubkey,
) -> Result<()> {
    let program = client.program(pid)?;

    let (sender, mut receiver) = mpsc::unbounded_channel();
    let event_unsubscriber = program
        .on(move |_, event: MyEvent| {
            if sender.send(event).is_err() {
                println!("Error while transferring the event.")
            }
        })
        .await?;

    sleep(Duration::from_millis(1000)).await;

    program
        .request()
        .args(events_instruction::Initialize {})
        .send()
        .await?;

    let event = receiver.recv().await.unwrap();
    assert_eq!(event.data, 5);
    assert_eq!(event.label, "hello".to_string());

    event_unsubscriber.unsubscribe().await;

    println!("Events success!");

    Ok(())
}

pub async fn basic_4<C: Deref<Target = impl Signer> + Clone>(
    client: &Client<C>,
    pid: Pubkey,
) -> Result<()> {
    let program = client.program(pid)?;
    let authority = program.payer();
    let (counter, _) = Pubkey::find_program_address(&[b"counter"], &pid);

    program
        .request()
        .accounts(basic_4_accounts::Initialize {
            counter,
            authority,
            system_program: system_program::ID,
        })
        .args(basic_4_instruction::Initialize {})
        .send()
        .await?;
    let counter_account: CounterAccount = program.account(counter).await?;
    assert_eq!(counter_account.authority, authority);
    assert_eq!(counter_account.count, 0);

    program
        .request()
        .accounts(basic_4_accounts::Increment { counter, authority })
        .args(basic_4_instruction::Increment {})
        .send()
        .await?;

    let counter_account: CounterAccount = program.account(counter).await?;
    assert_eq!(counter_account.authority, authority);
    assert_eq!(counter_account.count, 1);

    println!("Basic 4 success!");

    Ok(())
}

pub async fn optional<C: Deref<Target = impl Signer> + Clone>(
    client: &Client<C>,
    pid: Pubkey,
) -> Result<()> {
    // Program client.
    let program = client.program(pid)?;

    // `Initialize` parameters.
    let data_account_keypair = Keypair::new();

    let data_account_key = data_account_keypair.pubkey();

    let data_pda_seeds = &[DataPda::PREFIX.as_ref(), data_account_key.as_ref()];
    let data_pda_key = Pubkey::find_program_address(data_pda_seeds, &pid).0;
    let required_keypair = Keypair::new();
    let value: u64 = 10;

    // Build and send a transaction.

    program
        .request()
        .instruction(system_instruction::create_account(
            &program.payer(),
            &required_keypair.pubkey(),
            program
                .async_rpc()
                .get_minimum_balance_for_rent_exemption(DataAccount::LEN)
                .await?,
            DataAccount::LEN as u64,
            &program.id(),
        ))
        .signer(&data_account_keypair)
        .signer(&required_keypair)
        .accounts(OptionalInitialize {
            payer: Some(program.payer()),
            required: required_keypair.pubkey(),
            system_program: Some(system_program::id()),
            optional_account: Some(data_account_keypair.pubkey()),
            optional_pda: None,
        })
        .args(optional_instruction::Initialize { value, key: pid })
        .send()
        .await
        .unwrap();

    // Assert the transaction worked.
    let required: DataAccount = program.account(required_keypair.pubkey()).await?;
    assert_eq!(required.data, 0);

    let optional_pda = program.account::<DataPda>(data_pda_key).await;
    assert!(optional_pda.is_err());

    let optional_account: DataAccount = program.account(data_account_keypair.pubkey()).await?;
    assert_eq!(optional_account.data, value * 2);

    println!("Optional success!");

    Ok(())
}
